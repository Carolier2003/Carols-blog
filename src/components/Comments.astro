---
interface Props {
  slug: string;
}

const { slug } = Astro.props;
const apiBase = "https://api.kon-carol.xyz";
---

<div class="comments-section" data-slug={slug} data-api={apiBase}>
  <div class="section-header">
    <h3>评论</h3>
    <span class="count" id="comments-count"></span>
  </div>

  <div class="comments-list" id="comments-list">
    <div class="loading">加载中...</div>
  </div>

  <div class="comment-form">
    <div class="form-title" id="form-title">写下评论</div>
    <form id="comment-form">
      <input type="hidden" id="parent-id" name="parent_id" value="" />

      <div class="form-fields">
        <input
          type="text"
          id="author-name"
          name="author_name"
          placeholder="名字"
          required
          maxlength="50"
        />
        <input
          type="email"
          id="author-email"
          name="author_email"
          placeholder="邮箱（头像用）"
        />
      </div>

      <textarea
        id="comment-content"
        name="content"
        placeholder="分享你的想法..."
        required
        maxlength="5000"
        rows="3"
      ></textarea>

      <div class="form-actions">
        <button type="button" class="btn-cancel" id="cancel-reply" style="display: none;">
          取消
        </button>
        <button type="submit" class="btn-submit">
          <span class="btn-text">发布</span>
          <span class="btn-loading" style="display: none;">...</span>
        </button>
      </div>

      <div class="form-message" id="form-message"></div>
    </form>
  </div>
</div>

<script>
  class CommentSystem {
    private slug: string;
    private apiBase: string;
    private listEl: HTMLElement;
    private formEl: HTMLFormElement;
    private countEl: HTMLElement;
    private messageEl: HTMLElement;
    private formTitle: HTMLElement;
    private cancelBtn: HTMLButtonElement;
    private submitBtn: HTMLButtonElement;

    constructor(container: HTMLElement) {
      this.slug = container.dataset.slug || "";
      this.apiBase = container.dataset.api || "";
      this.listEl = container.querySelector("#comments-list")!;
      this.formEl = container.querySelector("#comment-form")!;
      this.countEl = container.querySelector("#comments-count")!;
      this.messageEl = container.querySelector("#form-message")!;
      this.formTitle = container.querySelector("#form-title")!;
      this.cancelBtn = container.querySelector("#cancel-reply")!;
      this.submitBtn = container.querySelector(".btn-submit")!;

      this.init();
    }

    private init() {
      this.loadComments();
      this.bindEvents();
    }

    private bindEvents() {
      this.formEl.addEventListener("submit", (e) => {
        e.preventDefault();
        this.submitComment();
      });

      this.cancelBtn.addEventListener("click", () => {
        this.clearReply();
      });

      this.listEl.addEventListener("click", (e) => {
        const target = e.target as HTMLElement;
        if (target.classList.contains("reply-link")) {
          const commentId = target.dataset.id;
          const authorName = target.dataset.name;
          if (commentId && authorName) {
            this.setReply(commentId, authorName);
          }
        }
      });
    }

    private async loadComments() {
      try {
        const response = await fetch(`${this.apiBase}/api/comments/${encodeURIComponent(this.slug)}`);
        const data = await response.json();

        if (data.success) {
          this.renderComments(data.comments, data.total);
        } else {
          this.listEl.innerHTML = '<div class="empty">加载失败</div>';
        }
      } catch (error) {
        this.listEl.innerHTML = '<div class="empty">加载失败，请刷新</div>';
      }
    }

    private renderComments(comments: any[], total: number) {
      this.countEl.textContent = total > 0 ? `${total}` : "";

      if (comments.length === 0) {
        this.listEl.innerHTML = '<div class="empty">暂无评论</div>';
        return;
      }

      const html = comments.map((comment) => this.renderComment(comment)).join("");
      this.listEl.innerHTML = html;
    }

    private renderComment(comment: any): string {
      const date = new Date(comment.created_at).toLocaleDateString("zh-CN", {
        month: "short",
        day: "numeric",
        hour: "2-digit",
        minute: "2-digit"
      });

      const repliesHtml = comment.replies?.length
        ? `<div class="replies">${comment.replies.map((r: any) => this.renderComment(r)).join("")}</div>`
        : "";

      return `
        <div class="comment" id="comment-${comment.id}">
          <img src="${comment.avatar_url}" alt="" class="avatar" loading="lazy" />
          <div class="content">
            <div class="meta">
              <span class="name">${this.escapeHtml(comment.author_name)}</span>
              <span class="time">${date}</span>
            </div>
            <div class="text">${this.formatContent(comment.content)}</div>
            <div class="actions">
              <button class="reply-link" data-id="${comment.id}" data-name="${this.escapeHtml(comment.author_name)}">回复</button>
            </div>
            ${repliesHtml}
          </div>
        </div>
      `;
    }

    private async submitComment() {
      const formData = new FormData(this.formEl);
      const data = {
        author_name: formData.get("author_name") as string,
        author_email: formData.get("author_email") as string,
        content: formData.get("content") as string,
        parent_id: formData.get("parent_id") ? parseInt(formData.get("parent_id") as string) : undefined,
      };

      this.setLoading(true);

      try {
        const response = await fetch(`${this.apiBase}/api/comments/${encodeURIComponent(this.slug)}`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(data),
        });

        const result = await response.json();

        if (result.success) {
          this.showMessage(result.message, "success");
          this.formEl.reset();
          this.clearReply();
          await this.loadComments();
        } else {
          this.showMessage(result.message || "发布失败", "error");
        }
      } catch (error) {
        this.showMessage("发布失败，请稍后重试", "error");
      } finally {
        this.setLoading(false);
      }
    }

    private setLoading(loading: boolean) {
      const btnText = this.submitBtn.querySelector(".btn-text") as HTMLElement;
      const btnLoading = this.submitBtn.querySelector(".btn-loading") as HTMLElement;
      this.submitBtn.disabled = loading;
      if (btnText) btnText.style.display = loading ? "none" : "inline";
      if (btnLoading) btnLoading.style.display = loading ? "inline" : "none";
    }

    private setReply(commentId: string, authorName: string) {
      const input = this.formEl.querySelector("#parent-id") as HTMLInputElement;
      input.value = commentId;
      this.formTitle.textContent = `回复 ${authorName}`;
      this.cancelBtn.style.display = "inline-block";
      this.formEl.scrollIntoView({ behavior: "smooth", block: "center" });
      (this.formEl.querySelector("#comment-content") as HTMLTextAreaElement).focus();
    }

    private clearReply() {
      const input = this.formEl.querySelector("#parent-id") as HTMLInputElement;
      input.value = "";
      this.formTitle.textContent = "写下评论";
      this.cancelBtn.style.display = "none";
    }

    private showMessage(message: string, type: "success" | "error") {
      this.messageEl.textContent = message;
      this.messageEl.className = `form-message ${type}`;
      setTimeout(() => {
        this.messageEl.textContent = "";
        this.messageEl.className = "form-message";
      }, 5000);
    }

    private escapeHtml(text: string): string {
      const div = document.createElement("div");
      div.textContent = text;
      return div.innerHTML;
    }

    private formatContent(content: string): string {
      return this.escapeHtml(content).replace(/\n/g, "<br>");
    }
  }

  document.addEventListener("DOMContentLoaded", () => {
    document.querySelectorAll(".comments-section").forEach((container) => {
      new CommentSystem(container as HTMLElement);
    });
  });
</script>

<style>
  .comments-section {
    margin-top: 4rem;
    padding-top: 2rem;
    border-top: 1px solid var(--border);
    font-size: 0.9375rem;
  }

  .section-header {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    margin-bottom: 1.5rem;
    color: var(--foreground);
  }

  .section-header h3 {
    font-size: 1rem;
    font-weight: 600;
    margin: 0;
  }

  .count {
    color: var(--muted);
    font-size: 0.875rem;
  }

  /* 评论列表 */
  .comments-list {
    margin-bottom: 2rem;
  }

  .loading,
  .empty {
    color: var(--muted);
    font-size: 0.875rem;
    padding: 1rem 0;
  }

  .comment {
    display: flex;
    gap: 0.75rem;
    padding: 1rem 0;
    border-bottom: 1px solid var(--border);
  }

  .comment:last-child {
    border-bottom: none;
  }

  .avatar {
    width: 28px;
    height: 28px;
    border-radius: 50%;
    flex-shrink: 0;
    opacity: 0.9;
  }

  .content {
    flex: 1;
    min-width: 0;
  }

  .meta {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    margin-bottom: 0.25rem;
  }

  .name {
    font-weight: 500;
    color: var(--foreground);
  }

  .time {
    font-size: 0.8125rem;
    color: var(--muted);
  }

  .text {
    color: var(--foreground);
    line-height: 1.6;
    word-break: break-word;
  }

  .actions {
    margin-top: 0.5rem;
  }

  .reply-link {
    font-size: 0.8125rem;
    color: var(--muted);
    background: none;
    border: none;
    padding: 0;
    cursor: pointer;
    transition: color 0.2s;
  }

  .reply-link:hover {
    color: var(--accent);
  }

  /* 嵌套回复 */
  .replies {
    margin-top: 1rem;
    padding-left: 1rem;
    border-left: 2px solid var(--border);
  }

  .replies .comment {
    padding: 0.75rem 0;
    border-bottom: none;
  }

  .replies .comment:first-child {
    padding-top: 0;
  }

  .replies .avatar {
    width: 24px;
    height: 24px;
  }

  /* 表单 */
  .comment-form {
    padding-top: 1rem;
  }

  .form-title {
    font-size: 0.9375rem;
    font-weight: 500;
    color: var(--foreground);
    margin-bottom: 0.75rem;
  }

  .form-fields {
    display: flex;
    gap: 0.75rem;
    margin-bottom: 0.75rem;
  }

  .form-fields input {
    flex: 1;
    padding: 0.5rem 0;
    font-size: 0.9375rem;
    color: var(--foreground);
    background: transparent;
    border: none;
    border-bottom: 1px solid var(--border);
    border-radius: 0;
    outline: none;
    transition: border-color 0.2s;
  }

  .form-fields input:focus {
    border-bottom-color: var(--accent);
  }

  .form-fields input::placeholder {
    color: var(--muted);
    opacity: 0.6;
  }

  textarea {
    width: 100%;
    padding: 0.75rem;
    font-size: 0.9375rem;
    color: var(--foreground);
    background: var(--background);
    border: 1px solid var(--border);
    border-radius: 0.375rem;
    outline: none;
    resize: vertical;
    min-height: 80px;
    margin-bottom: 0.75rem;
    transition: border-color 0.2s;
  }

  textarea:focus {
    border-color: var(--accent);
  }

  textarea::placeholder {
    color: var(--muted);
    opacity: 0.6;
  }

  .form-actions {
    display: flex;
    gap: 0.75rem;
    align-items: center;
  }

  .btn-submit,
  .btn-cancel {
    padding: 0.5rem 1rem;
    font-size: 0.875rem;
    font-weight: 500;
    border-radius: 0.375rem;
    cursor: pointer;
    transition: all 0.2s;
  }

  .btn-submit {
    color: white;
    background: var(--foreground);
    border: none;
  }

  .btn-submit:hover:not(:disabled) {
    opacity: 0.8;
  }

  .btn-submit:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  .btn-cancel {
    color: var(--muted);
    background: transparent;
    border: none;
  }

  .btn-cancel:hover {
    color: var(--foreground);
  }

  .form-message {
    margin-top: 0.75rem;
    font-size: 0.875rem;
  }

  .form-message.success {
    color: var(--accent);
  }

  .form-message.error {
    color: #dc2626;
  }

  @media (max-width: 480px) {
    .form-fields {
      flex-direction: column;
      gap: 0.5rem;
    }
  }
</style>
